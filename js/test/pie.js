// Generated by CoffeeScript 1.3.3
(function() {
  var Arc_Segment, Column, Line_Segment, Pie, Pie_Top, Pie_Top_Flower, Segment, Side_Column, Simple_Path, Slice, add_side_column, colors, create_arc, create_controls, debug_point, debug_points, iris, rad, to_rad;

  MetaHub.import_all();

  Bloom.import_all();

  Breeze.import_all();

  to_rad = 2 * Math.PI / 360;

  rad = 2 * Math.PI;

  Segment = Meta_Object.sub_class('Segment', {
    draw: function() {
      return null;
    }
  });

  Line_Segment = Meta_Object.sub_class('Line_Segment', {
    draw: function(point) {
      return "L" + point.x + "," + point.y;
    }
  });

  Arc_Segment = Meta_Object.sub_class('Arc_Segment', {
    radius: new Point(0, 0),
    large_sweep: 0,
    initialize: function(radius, large_sweep) {
      this.radius = radius;
      return this.large_sweep = large_sweep;
    },
    draw: function(point) {
      return "A" + this.radius.x + "," + this.radius.y + " 0 " + this.large_sweep + ",0 " + point.x + "," + point.y;
    }
  });

  Simple_Path = Petal.sub_class('Simple_Path', {
    stroke_width: 3,
    stroke: "#333333",
    fill: "red",
    opacity: 1,
    position: new Point(0, 0),
    initialize: function(slice) {
      this.element = Iris.create_element("path");
      return this.arc = slice;
    },
    render: function() {
      var element;
      element = this.element;
      element.setAttribute("stroke", this.stroke);
      element.setAttribute("stroke-width", this.stroke_width);
      element.setAttribute("fill", this.fill);
      element.setAttribute("opacity", this.opacity);
      element.setAttribute("stroke-linecap", 'round');
      element.setAttribute("stroke-linejoin", 'round');
      element.setAttribute("transform", 'translate(' + this.position.x + ',' + this.position.y + ')');
      return element.setAttribute("d", this.path);
    },
    copy: function() {
      var name, properties, property, result, _i, _len;
      result = this.meta_source.create();
      properties = Object.keys(this.meta_source.properties).concat(Object.keys(Simple_Path.properties));
      for (_i = 0, _len = properties.length; _i < _len; _i++) {
        name = properties[_i];
        property = this[name];
        if (typeof property === 'object') {
          result[name] = new Point(property.x, property.y);
        } else {
          result[name] = property;
        }
      }
      result.path = this.path;
      return result;
    },
    partial_methods: function(start, end, inc, source) {
      var methods, x, y;
      methods = [];
      x = start;
      y = 0;
      while (x !== end) {
        if (inc < 0) {
          methods.push(source[this.shift_value(x, inc, source.length)]);
        } else {
          methods.push(source[x]);
        }
        if (y++ > 5) {
          throw new Error('Infinite loop!');
        }
        x = this.shift_value(x, inc, source.length);
      }
      return methods;
    },
    partial_points: function(start, end, inc, source, offset) {
      var point, points, x, y;
      points = [];
      x = start;
      y = 0;
      while (x !== end) {
        point = source[this.shift_value(x, inc, source.length)];
        if (offset) {
          points.push(new Point(point.x + offset.x, point.y + offset.y));
        } else {
          points.push(point.copy());
        }
        if (y++ > 5) {
          throw new Error('Infinite loop!');
        }
        x = this.shift_value(x, inc, source.length);
      }
      return points;
    },
    render_path: function(points, methods) {
      var i, path, x;
      path = 'M' + points[0].x + "," + points[0].y;
      x = 0;
      while (x < points.length) {
        i = (x + 1) % points.length;
        path += ' ' + methods[x].draw(points[i]);
        x++;
      }
      return path;
    },
    shift_value: function(value, mod, max) {
      value = (value + mod) % max;
      if (value < 0) {
        value += max;
      }
      return value;
    }
  });

  Column = Simple_Path.sub_class('Column', {
    path: '',
    height: 100,
    initialize: function(arc) {
      this.arc = arc;
      return this.height = arc.height;
    },
    generate: function(arc, start, end, dir) {
      var points;
      points = arc.points;
      this.points = [points[start]].concat(this.partial_points(start, end, dir, points));
      this.methods = this.partial_methods(start, end, dir, arc.methods);
      this.points.push(new Point(points[end].x, points[end].y + arc.height));
      this.methods.push(Line_Segment.create());
      this.points = this.points.concat(this.partial_points(end, start, dir, points, new Point(0, arc.height)));
      this.methods = this.methods.concat(this.partial_methods(end, start, dir, arc.methods));
      this.methods.push(Line_Segment.create());
      return this.path = this.render_path(this.points, this.methods) + 'z';
    },
    update: function() {
      return this.path = this.generate(this.arc, this.arc.start, this.arc.end, 1);
    }
  });

  Side_Column = Column.sub_class('Side_Column', {
    initialize: function() {
      this.fill = 'white';
      return this.opacity = 0.25;
    },
    update: function() {
      return this.generate(this.arc, this.arc.start, this.shift_value(this.arc.start, this.dir, this.arc.points.length), this.dir);
    }
  });

  Slice = Meta_Object.sub_class('Slice', {
    parts: [],
    initialize: function(position, radius, start, end) {
      this.position = position;
      this.radius = radius;
      this.value = Meta_Object.value;
      this.listen(this, 'change.amount', this.amount_changed);
      return this.element = Iris.create_element('g');
    },
    amount_changed: function(amount, old_amount) {
      if (this.parent.animating) {
        return this.listen(this.parent, 'animated', function() {
          return this.animate(amount, old_amount);
        });
      } else {
        return this.animate(amount, old_amount);
      }
    },
    animate: function(amount, old_amount) {
      var span, timer, x,
        _this = this;
      amount = parseInt(amount);
      this.parent.animating = true;
      span = amount - old_amount;
      x = 0;
      return timer = setInterval(function() {
        _this.amount = old_amount + (span * x);
        if (x >= 1) {
          _this.amount = amount;
          clearInterval(timer);
          _this.parent.animating = false;
          return _this.parent.invoke('animated');
        } else {
          x += 0.1;
          _this.parent.update();
          return _this.parent.render();
        }
      }, 10);
    },
    create_part: function(type, color, opacity) {
      var part;
      part = type.create(this);
      part.fill = color;
      part.opacity = opacity;
      this.parts.push(part);
      this.element.appendChild(part.element);
      return part;
    },
    get_angle_point: function(angle) {
      var arc_x, arc_y, degree;
      degree = angle * 360;
      arc_x = Math.cos(degree * to_rad) * this.radius.x;
      arc_y = Math.sin(degree * to_rad) * this.radius.y;
      return Point.create(arc_x, -arc_y);
    },
    update: function() {
      var end, left, part, right, sides, start, _i, _len, _ref, _results;
      start = this.get_angle_point(this.start_angle);
      end = this.get_angle_point(this.end_angle);
      if (Math.abs(this.end_angle - this.start_angle) > 0.5) {
        this.large_sweep = 1;
      } else {
        this.large_sweep = 0;
      }
      this.points = [new Point(0, 0), start, end];
      this.methods = [Line_Segment.create(), Arc_Segment.create(this.radius, this.large_sweep), Line_Segment.create()];
      if (this.start_angle < 0.5 && this.end_angle > 0.5) {
        this.points.splice(2, 0, new Point(-this.radius.x, 0));
        this.methods.splice(2, 0, this.methods[1]);
      }
      sides = this.points.map(function(p) {
        return p.x;
      });
      left = sides.reduce(function(x, y) {
        return Math.min(x, y);
      });
      right = sides.reduce(function(x, y) {
        return Math.max(x, y);
      });
      this.start = sides.indexOf(right);
      this.end = sides.indexOf(left);
      _ref = this.parts;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
        _results.push(part.update());
      }
      return _results;
    },
    render: function() {
      var part, _i, _len, _ref, _results;
      this.element.setAttribute("transform", 'translate(' + this.position.x + ',' + this.position.y + ')');
      _ref = this.parts;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        part = _ref[_i];
        _results.push(part.render());
      }
      return _results;
    }
  });

  Pie_Top = Simple_Path.sub_class("Pie_Top", {
    fill: 'white',
    update: function() {
      return this.path = this.render_path(this.arc.points, this.arc.methods) + 'z';
    }
  });

  iris = {};

  create_arc = function(startx, starty, radiusx, radiusy, endx, endy, positionx, positiony) {
    var result;
    result = Pie_Top.create();
    result.start = Point.create(startx, starty);
    result.radius = Point.create(radiusx, radiusy);
    result.end = Point.create(endx, endy);
    result.position = Point.create(positionx, positiony);
    return result;
  };

  debug_point = function(point, offset, color) {
    var circle;
    color = color || 'white';
    circle = Circle.create(point.x, point.y, 4);
    circle.element.setAttribute('fill', color);
    circle.element.setAttribute('stroke', 'black');
    circle.element.setAttribute('stroke-width', 2);
    circle.element.setAttribute("transform", 'translate(' + offset.x + ',' + offset.y + ')');
    return iris.debug_layer.appendChild(circle.element);
  };

  debug_points = function(points, offset) {
    var point, x, _i, _len, _results;
    x = 0;
    _results = [];
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      point = points[_i];
      _results.push(debug_point(point, offset, colors[x++]));
    }
    return _results;
  };

  add_side_column = function(arc, dir, color, opacity) {
    var side_column;
    side_column = arc.create_part(Side_Column, color, opacity);
    return side_column.dir = dir;
  };

  colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];

  Pie = Meta_Object.sub_class('Pie', {
    position: new Point(400, 300),
    initialize: function(items, options) {
      var arc, item, radius, y, _i, _len, _results;
      this.optimize_getter('arcs', 'slice');
      this.options = options;
      y = 0;
      radius = 100;
      _results = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        arc = Slice.create(this.position, new Point(radius, radius * 0.7));
        arc.amount = item.amount;
        this.connect(arc, 'slice', 'parent');
        _results.push(this.create_parts(arc, colors[y++], options));
      }
      return _results;
    },
    create_parts: function(arc, color, options) {
      arc.bottom = arc.create_part(Pie_Top, 'black', 0.6);
      add_side_column(arc, -1, 'black', 0.6);
      arc.create_part(Column, color, 0.7);
      add_side_column(arc, 1, 'white', 0.3);
      return arc.create_part(Pie_Top, 'white', 0.6);
    },
    render: function() {
      var arc, arcs, paper, _i, _len, _results;
      console.log('rendering');
      paper = iris.layers[0];
      arcs = Array.apply(null, this.arcs);
      arcs.sort(function(a, b) {
        return b.middley - a.middley;
      });
      _results = [];
      for (_i = 0, _len = arcs.length; _i < _len; _i++) {
        arc = arcs[_i];
        if (arc.element.parentNode) {
          paper.removeChild(arc.element);
        }
        paper.appendChild(arc.element);
        _results.push(arc.render());
      }
      return _results;
    },
    update: function() {
      var arc, arcs, degree, offset, position, span, total, x, _i, _j, _len, _len1, _ref, _results;
      console.log('updating');
      total = this.arcs.reduce(function(x, y) {
        return (x.amount || x) + y.amount;
      });
      position = 0;
      x = this.arcs.length;
      _ref = this.arcs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arc = _ref[_i];
        arc.start_angle = position;
        arc.end_angle = position += arc.amount / total;
        degree = ((arc.end_angle - arc.start_angle) / 2 + arc.start_angle) * 360;
        arc.middley = Math.sin(degree * to_rad) * arc.radius.y;
      }
      arcs = Array.apply(null, this.arcs);
      arcs.sort(function(a, b) {
        return b.middley - a.middley;
      });
      span = arcs[0].middley - arcs[arcs.length - 1].middley;
      console.log(span);
      _results = [];
      for (_j = 0, _len1 = arcs.length; _j < _len1; _j++) {
        arc = arcs[_j];
        offset = (arc.middley * 0.7) + 40;
        arc.position = this.position.copy();
        arc.position.y -= offset;
        arc.arc_middle = arc.get_angle_point((arc.end_angle - arc.start_angle) / 2 + arc.start_angle);
        arc.position.add(new Point(arc.arc_middle.x * this.options.gap, arc.arc_middle.y * this.options.gap));
        arc.height = 100 + (offset * 0.7);
        arc.bottom.position.y = arc.height;
        _results.push(arc.update());
      }
      return _results;
    }
  });

  $(function() {
    var items, options;
    iris = Iris.create('content', 800, 600);
    iris.debug_layer = Iris.create_element("g");
    iris.element.appendChild(iris.debug_layer);
    items = [];
    items.push({
      name: 'Name',
      amount: 20
    });
    items.push({
      name: 'Name',
      amount: 15
    });
    items.push({
      name: 'Name',
      amount: 20
    });
    items.push({
      name: 'Name',
      amount: 40
    });
    items.push({
      name: 'Name',
      amount: 17
    });
    items.push({
      name: 'Name',
      amount: 20
    });
    options = {
      gap: 0.07
    };
    window.pie = Pie.create(items, options);
    create_controls(pie.arcs);
    pie.update();
    return pie.render();
  });

  Pie_Top_Flower = Flower.sub_class('Pie_Top_Flower', {
    initialize: function() {
      var input,
        _this = this;
      this.element = $('<div><input type="text"></div>');
      input = this.element.find('input');
      input.val(this.seed.amount);
      return Bloom.watch_input(input, function() {
        return _this.seed.animate(input.val(), _this.seed.amount);
      });
    }
  });

  create_controls = function(arcs) {
    var arc, flower, list, _i, _len, _results;
    list = List.create($('#controls'));
    _results = [];
    for (_i = 0, _len = arcs.length; _i < _len; _i++) {
      arc = arcs[_i];
      flower = Pie_Top_Flower.create(arc);
      _results.push(list.connect(flower, 'child', 'parent'));
    }
    return _results;
  };

}).call(this);
